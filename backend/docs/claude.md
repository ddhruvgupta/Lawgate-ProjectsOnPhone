# Claude.ai Long-Term Memory Context - Backend

## Backend Architecture

### Technology: .NET 8 Web API
- Latest LTS version (Long Term Support until Nov 2026)
- Modern C# features (C# 12)
- High performance with minimal API overhead
- Native async/await throughout

### Database Access: Entity Framework Core 8
- Code-first approach with migrations
- PostgreSQL provider (Npgsql)
- Automatic change tracking
- LINQ query support

### Key Design Patterns
1. **Repository Pattern** - Abstraction over data access
2. **Unit of Work** - Transaction management
3. **Dependency Injection** - Built-in .NET DI container
4. **Middleware Pipeline** - Request/response processing
5. **DTOs** - Separation of API contracts from domain models

## Critical Files & Their Purpose

### `Program.cs`
- Application entry point
- Service registration (DI container)
- Middleware pipeline configuration
- CORS, authentication, Swagger setup

### `Data/ApplicationDbContext.cs`
- EF Core database context
- Entity configurations
- Audit trail implementation
- Database set properties

### `Data/DbSeeder.cs`
- Initial data seeding
- Default roles creation
- Admin user setup
- Development test data

### `Migrations/`
- Database schema versions
- Generated by EF Core
- Applied in order by timestamp
- **Never manually edit these!**

## Authentication Flow

```
1. User registers → POST /api/auth/register
   - Password hashed with BCrypt
   - User stored in database
   - Returns user info (no password)

2. User logs in → POST /api/auth/login
   - Verify email + password
   - Generate JWT token
   - Return token + user info

3. Client stores token → localStorage/sessionStorage

4. Subsequent requests → Include token in header
   - Authorization: Bearer <token>
   - Middleware validates token
   - User identity attached to request

5. Token expires → Refresh or re-login
```

## Database Context Specifics

### Connection String Format
```
Host=hostname;Database=dbname;Username=user;Password=pass;[SslMode=Require for Azure]
```

### Migration Commands (Remember These!)
```powershell
# Create new migration
dotnet ef migrations add MigrationName

# Apply migrations to database
dotnet ef database update

# Generate SQL script (for manual review)
dotnet ef migrations script

# Rollback to specific migration
dotnet ef database update PreviousMigrationName

# Remove last unapplied migration
dotnet ef migrations remove
```

## API Response Patterns

### Success Response
```json
{
  "success": true,
  "data": { /* result */ },
  "message": "Operation completed successfully"
}
```

### Error Response
```json
{
  "success": false,
  "error": "Error message",
  "errors": ["Validation error 1", "Validation error 2"],
  "timestamp": "2026-01-11T10:30:00Z"
}
```

## Security Implementation

### Password Hashing
- **BCrypt** with automatic salt generation
- Work factor: 12 (configurable)
- Never store plain-text passwords
- One-way hash (cannot be reversed)

### JWT Token Structure
```
Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "sub": "userId", "email": "user@example.com", "role": "User", "exp": timestamp }
Signature: HMACSHA256(header + payload, secret)
```

### CORS Configuration
- Allow specific origins only
- Credentials allowed for cookies
- Specific methods and headers
- No wildcard (*) in production

## Entity Framework Best Practices

### Query Optimization
```csharp
// ✅ Good - Async, NoTracking for read-only
var users = await context.Users
    .AsNoTracking()
    .Where(u => u.IsActive)
    .ToListAsync();

// ❌ Bad - Synchronous, tracking overhead
var users = context.Users.Where(u => u.IsActive).ToList();
```

### Eager Loading
```csharp
// ✅ Load related data in one query
var user = await context.Users
    .Include(u => u.Role)
    .FirstOrDefaultAsync(u => u.Id == id);

// ❌ Causes N+1 query problem
var users = await context.Users.ToListAsync();
foreach(var user in users) {
    var role = await context.Roles.FindAsync(user.RoleId); // Extra query each time!
}
```

### Change Tracking
```csharp
// ✅ Explicit updates
var user = await context.Users.FindAsync(id);
user.Name = "New Name";
await context.SaveChangesAsync(); // EF detects changes

// ✅ Manual tracking for complex scenarios
context.Entry(user).State = EntityState.Modified;
```

## Common Development Tasks

### Adding a New Entity
1. Create model class in `Models/`
2. Add DbSet to `ApplicationDbContext`
3. Create entity configuration in `Data/Configurations/`
4. Create migration: `dotnet ef migrations add AddEntityName`
5. Apply migration: `dotnet ef database update`
6. Create DTOs in `DTOs/`
7. Create controller in `Controllers/`
8. Update Swagger documentation

### Adding a New API Endpoint
1. Create/update controller in `Controllers/`
2. Add action method with HTTP verb attribute
3. Add authorization attribute if needed
4. Add XML comments for Swagger
5. Create/update DTOs
6. Implement business logic in service layer
7. Test with Swagger UI

### Modifying Database Schema
1. Update entity model
2. Update entity configuration if needed
3. Create migration: `dotnet ef migrations add DescriptiveChangeNameHere`
4. Review generated migration in `Migrations/`
5. Apply: `dotnet ef database update`
6. Update seed data if applicable
7. Update documentation

## Environment Configuration

### appsettings.json (Template)
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "DO_NOT_COMMIT_REAL_CONNECTION_STRING"
  },
  "Jwt": {
    "Key": "DO_NOT_COMMIT_REAL_KEY",
    "Issuer": "lawgate-api",
    "Audience": "lawgate-client",
    "ExpiryMinutes": 60
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Information"
    }
  }
}
```

### User Secrets (Development)
```powershell
# Initialize user secrets
dotnet user-secrets init

# Set connection string
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "Host=localhost;Database=lawgate_db;Username=lawgate_user;Password=dev_password"

# Set JWT key
dotnet user-secrets set "Jwt:Key" "your-super-secret-key-at-least-32-characters-long"

# List secrets
dotnet user-secrets list
```

### Azure Configuration
- Use **Azure Key Vault** for secrets
- Set connection strings in App Service Configuration
- Enable managed identity
- Use Application Insights for monitoring

## Performance Considerations

### Async/Await
- All database calls must be async
- Use `async Task<T>` for methods
- Await all async calls
- Don't mix sync and async code

### Response Compression
- Enabled in production
- Gzip compression for API responses
- Reduces bandwidth usage

### Caching Strategy
- In-memory cache for reference data
- Distributed cache (Redis) for scale-out
- Cache invalidation on updates

## Testing Strategy

### Unit Tests
- Test business logic in services
- Mock DbContext with InMemory provider
- Use xUnit framework
- FluentAssertions for readable tests

### Integration Tests
- Test full API endpoints
- Use TestServer from ASP.NET Core
- Testcontainers for real PostgreSQL
- Reset database between tests

## Deployment Checklist

- [ ] Update `appsettings.Production.json` (without secrets)
- [ ] Configure Azure Key Vault references
- [ ] Set HTTPS redirection
- [ ] Enable Application Insights
- [ ] Configure health checks
- [ ] Set up automated backups
- [ ] Configure scaling rules
- [ ] Test database migrations on staging
- [ ] Review and restrict CORS origins
- [ ] Enable rate limiting
- [ ] Set up monitoring alerts

## Troubleshooting Guide

### "Cannot connect to database"
1. Check connection string
2. Verify PostgreSQL is running
3. Check firewall rules
4. Test with psql: `psql -h host -U user -d database`

### "Migration pending"
```powershell
dotnet ef migrations list  # Check status
dotnet ef database update  # Apply pending
```

### "JWT token invalid"
1. Check token expiration
2. Verify JWT key matches
3. Check issuer/audience match
4. Ensure HTTPS in production

### "Slow queries"
1. Check EF Core logs (set LogLevel to Debug)
2. Look for N+1 query problems
3. Add indexes to frequently queried columns
4. Use AsNoTracking for read-only queries

## Remember for Future Claude

### When user returns after 1 year:
1. Migrations are version-controlled - run `dotnet ef database update`
2. DbSeeder creates initial data automatically
3. User secrets are local - regenerate with `dotnet user-secrets set`
4. All schema in code - no manual database setup needed
5. Run `database/recreate-database.ps1` for complete reset

### Key Commands to Know:
```powershell
# Full rebuild
dotnet clean && dotnet restore && dotnet build

# Database from scratch
dotnet ef database drop -f && dotnet ef database update

# Run with seeding
dotnet run --seed-data

# Watch mode (hot reload)
dotnet watch run
```

## Next Steps (TODO)
- [ ] Implement rate limiting middleware
- [ ] Add Redis caching layer
- [ ] Set up health checks with dependencies
- [ ] Add API versioning
- [ ] Implement audit logging middleware
- [ ] Add comprehensive validation
- [ ] Set up integration tests
- [ ] Configure Application Insights
